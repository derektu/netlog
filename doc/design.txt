=============================================
Log.IO improvement
=============================================

- client log 傳送
  - http post
  - uri = http://logserver/appID/logID
    - appID由使用者自己決定, 通常用來區分產品
    - logID由使用者自己決定, 可以是某個instance name, e.g. userID,
    - 一個appID可以有多個logID

  - post內容為array of log string

    "['log1', 'log2']"

    每一個log的內容為

      "<level>|log message\r\n"

    where
      level = debug, info, warn, error, fatal. Level是有層級的: debug < info < warn < error < fatal. WebUI會提供filter
      log message的內容則由client自己決定

- server端log 'persistence'
  - 同一個appID/logID內的log keep最近2天內的最後N則

  - implementation的方式
    - log資料存放在list內, key=appID|logID
    - 收到log時
      - add key to set (用來知道目前有哪些log是available的)
      - generate log unique index (incr), 用這個來當這一筆log的unique index
      - add to list (index, log)
      - update key的expire time (目前server時間 + expire period)
      - 
      - TODO: broadcast to web client for realtime update

    - 定時維護機制
      - 檢查key set內是否有某些key已經expire了, if so, remove key from set
      - 檢查每個key的log的count是否已經超過limit, if so, purge from list

  - client端API
    - 取得list of appID
    - 取得某個appID內的所有logID

    - ref某個appID/logID
      - 取得這個key目前的index,
      - 從這個位置往前讀取N筆歷史資料 (note: might conflict with purge operation, 可以使用index來判斷資料的連續性),
        把資料傳給client,
      - 把這筆index以後的log自動push給client,

---------------------------------------------------
NetLog Redis design
---------------------------------------------------

- 記錄logs的key
  
  - key = appID|logID|list
  - 使用list來存logdata
  - 使用expire來implement TTL 

    rpush appID|logID|list logdata1
    rpush appID|logID|list logdata2

    expire appID|logID|list n  
      - n = 24 * 60 * 60 * 2 = 2天
      - 每次寫log時就update (rolling expire policy)

    exists appID|logID|list 
      - 檢查這個key是否還存在
      - return "0" if not exists

    keys *|*|list
      - 這樣子可以找到目前所有valid的(list) keys

- 記錄log的流水號
  - 由於log資料會被purge, 所以我們不能使用list的index來記錄哪些log該送給user,
  - 為此我們在每一筆logdata會attach一個increasing的seqno,
  - 當client要開始subscribe某個log的資料時, 我們先取出目前這個log最後一筆的seqno, 標記資料的位置, 
  - 當我們收到新的log資料的時後, 由於產生的seqno會大於這個號碼, 所以我們知道該送給client,
  - 同時我們也會從目前list的位置往回讀'歷史'log資料來送給client,
  - 我們可以利用這個seqno, 以及他是increasing的特性來確認送給client的log不會重複

  - key = appID|logID|seqno
  - 使用incr來記錄數值

---------------------------------------------------
Object design
---------------------------------------------------

- LogServer
  - logserver, 處理log request
    - 根據uri取出
      - appID, logID, 
      - array of logrecord

    - pass給LogDB to write

- LogDB
  - 處理logrecord的讀寫
  - 當logServer收到request後傳入
    - appID/logID
    - array of logrecord

    - 寫入redis之後, 送出logReady event (webserver會接受這個event, 然後傳給他的clients)

  - 提供讀取歷史log資料的API
  - 提供取得available appID/logID的API

- WebServer
  - 處理client的request
  - 只support socket.io protocol

  - API: 取得available的appID
  - API: 取得某個appID內的logID
  - API: register appID/logID
    - 送給client的資料內要標明這是新的資料 or 歷史資料

  - API: unregister appID/logID


- class LogRecord
  { seqno: 0, level: 'info', message: '..' }


- LogEntry
  - 記錄一筆log資料,
  - property 
    - seqno
    - level
    - message

  - method
    - parseFromRequest(logRequest)  
    - setSeqNo(seqNo)
    - 


- WebServer
  - webserver, 傳送log給client, etc.  
